# Реферат
## по курсу "Логическое программирование"

### студент: Ядров А. Л.

## ТЕМА Как научить вашу бабушку/дедушку логическому программированию.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

# Введение в логическое программирование

Для начала поговорим, что такое логическое программирование и зачем оно может понадобится нашим бабушкам/дедушкам. Логическое программирование - это лишь одна из многих парадигм программирования, которая основана на теории и аппарате математической логики предикатов. В отличие от императивных языков в языке логического программирования не надо расписывать четкий алгоритм действий, достаточно лишь задать предикат. Возьмем, к примеру, программу, которая дифференцирует выражение. На языке `Prolog` она будет выглядеть следующим образом:
```prolog
d(X, X, 1) :- !.
d(T, X,0) :- atomic(T).

d(U+V, X, DU+DV) :- d(U, X, DU), d(V, X, DV).
d(U-V, X, DU-DV) :- d(U, X, DU), d(V, X, DV).
d(-T, X, -R) :- d(T, X, R).
d(C*U, X, C*DU) :- atomic(C), C\\=X, !, d(U,X, DU).
d(U*V, X, V*DU+U*DV) :- d(U, X, DU), d(V, X, DV).
d(U/V, X, (DU*V-U*DV)/(V*V)) :- d(U, X, DU), d(V, X, DV).
```
И если мы попробуем продифференцировать выражение `(x+1)/(x-1)` по `x` и обратимся к вышенаписанной программе, то `Prolog` выдаст следующий результат:
```prolog
?-d((x-1)/(x+1), x, R).
R = ((1-0)*(x+1)-(1-0)*(x-1))/((x-1)*(x-1))
```
Написать такую же программу на императивном языке программирования, к примеру, на С, довольно сложно. Можно лишь рассчитать производную функцию в заданной точке, используя численные методы.
```c
double f(double x)
{
  //здесь функция, производную которой нужно найти, например, x^2
  return x * x;
}
 
main()
{ 
  double x, h, fl, fr, fc, f2;
 
  x = 1; // точка, в которой вычисляем производную
  h = 0.1; // шаг, с которым вычисляем производную
 
  // приближенно вычисляем первую производную различными способами
  fl = (f(x) - f(x - h)) / h; // левая
  fr = (f(x + h) - f(x)) / h; // правая
  fc = (f(x + h) - f(x - h)) / (2 * h); // центральная
 
  // приближенно вычисляем вторую производную
  f2 = (f(x + h) - 2 * f(x) + f(x - h)) / (h * h);
  ```
  Однако этот метод не всегда вычисляет точную производную. Также есть статья ["Вычисление производных с помощью шаблонов на С++"](https://habr.com/ru/post/149470/).
  
  Итак, как мы видим, преимущество языка Prolog в его простоте в сравнении с императивными языками программирования. Поэтому обучить бабушку/дедушку программировать на Prolog гораздо легче, чем научить программировать на C/C++.
  Однако, я не уверен, что нашим бабушкам/дедушкам хочется высчитывать производные. Prolog может решать более простые задачи, в частности, служить базой данных, а также обрабатывать эту самую базу данных. Дело в том, что программа на языке Prolog состоит из фактов и правил. Факты как раз будут составлять нашу базу данных, а правила - обрабатывать ее. Как же можно применить это нашим бабушкам/дедушкам? Не секрет, что с возврастом мы знакомы всё с бОльшим количеством людей, однако, память при этом нисколько не возрастает. Поэтому нам сложнее запоминать какие-то факты, например, номера телефонов наших родных, близких, друзей, знакомых. Поэтому мы можем научить наших бабушек/дедушек составлять базу данных на языке Prolog. Также мы можем научить программу обрабатывать наш языковой запрос, чтобы другие бабушки/дедушки могли использовать нашу базу данных.
# База данных
Итак, мы знаем, что программа языка Prolog состоит из фактов и правил. Факты служат нашей базой данных, а правила, в свою очередь, обрабатывают ее. Для того, чтобы обучить бабушку/дедушку программированию напишем простейшую базу данных, которая состоит из двух полей: Имя контакта и номер телефона. Для того, чтобы составить базу данных, нужно написать некоторый предикат. Назовем этот предикат `phone_number`. Предикат `phone_number` должен принимать имя и номер телефона. Отлично, составим парочку фактов.
```prolog
phone_number('Внук', 89314456381).
phone_number('Соседка', 89871754437).
```
Очевидно, бабушка или дедушка спросит, почему названия контактов мы записываем в одинарные ковычки. Дело в том, что выражения, начинающиеся с заглавной буквы Prolog в реализации SWI-Prolog будет воспринимать как переменные. Однако, в языке есть такое понятие, как атом. Атом представляет собой произвольную последовательность символов, заключенную в одинарные кавычки. Одинарный символ кавычки, встречающийся внутри атома, записывается дважды. Когда атом выводится на печать, внешние символы кавычек обычно не печатаются.
Теперь попробуем обратиться и узнать номер внука. Для этого запустим программу `example.pl`. Например, на ОС Fedora это будет выглядеть следующим образом:
```bash
 [yadroff@fedora lp-capstone-Yadroff-master]$ swipl example.pl 
Welcome to SWI-Prolog (threaded, 64 bits, version 8.4.1)
SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.
Please run ?- license. for legal details.

For online help and background, visit https://www.swi-prolog.org
For built-in help, use ?- help(Topic). or ?- apropos(Word).

?- phone_number('Внук', X).
X = 89314456381
```
Теперь настало время объяснить нашим бабушкам/дедушкам, почему X принял именно это значение. Для этого надо объяснить, как же происходит обработка запроса в языке Prolog. Prolog пытается отождествить термы (объект данных) при доказательстве, или согласовании, целевого утверждения. В данном случае терм X утверждение `phone_number('Внук', X)` было отожествленно с фактом `phone_number('Внук', 89314456381)`, в результате чего переменная X стала конкретизованной: X = 89314456381.
А что, если мы введем запрос `phone_number(X,Y)`? Тогда Prolog сначала конкретизует переменную X, затем - Y. Проиллюстрируем это.
![2021_12_19_0yv_Kleki](https://user-images.githubusercontent.com/90184435/146685457-c1e0706f-3741-4e16-aa09-e665541f11d2.png)
В данном случае в логическом программировании просто перебираются все варианты. Сначала подставляется по X, а затем по Y. Если находится существующий предикат, где все объекты определены и правильно расставлены, то это решение. Если не существует такого предиката, то перебираем следующие варианты. Как пример я привел поиск относительно поддерева с молоком, ведь поддеревья с яйцом и мукой разбираются аналогично. Зеленым я выделил существующий предикат, объекты которого определены и правильно расставлены - это и является одним из решений поиска.
# Списки
Списки в Prolog - одна из важнейших структур данных. Списки используются всегда, когда надо объединить несколько термов. Списки в прологе задаются с помощью квадратных скобок. Например, в нашей программе необходимо найти номера некоторого списка людей.
Список можно объявить следующим образом: 
```prolog
list_syntax:-
% объявление списка из трех чисел с именем ListA:
   ListA = [7, 5, 3],
% разделение списка на первый элемент (переменная с именем Head)
% и остальную часть списка (Tail)
% в результате Head = 7, Tail = [5, 3]:
   ListA = [Head|Tail],
% формирование списка ListB из нового элемента, Head и tail:
% в результате ListB = [7, 9, 5, 3]
   ListB = [Head, 9|Tail].
```
Для работы со списком есть множество методов, о которых можно узнать по [ссылке](https://www.swi-prolog.org/pldoc/man?section=lists). Теперь напишем обход списка контактов, который будет записывать в результирующий список номера этих контактов.
```prolog
phone_number('Внук', 89314456381).
phone_number('Соседка', 89871754437).
phone_number([],[]).
phone_number([X|T], Res) :-  phone_number(X, Z),  phone_number(T, Y), append([Z], Y, Res). 
%append(?List1, ?List2, ?List1AndList2)
List1AndList2 is the concatenation of List1 and List2
```
Тут используется рекурсивный обход списка: список разбивается на голову и хвост, обрабатывается сначала голова, а затем хвост - список без первого элемента.
# Естественно-языковой интерфейс
Теперь научим нашу программу отвечать на некоторые естественно-языковые запроссы, чтобы ей могли пользоваться другие. В качестве примера, возьмем следующие запросы на английском:
1. Whose number is num? (В качестве num подразумевается номер телефона).
2. What number has X? (В качестве X подразумевается название контакта).
3. Is Y number X? (Является ли номер Y номером контакта X).
Английский выбран из двух соображений:
1. Обработка английского языка проще, так как в нем нет родов, есть четкая структура предложения.
2. Наши бабушки/дедушки смогут вспомнить английский язык.
Итак, запрос будет представлять список слов, который в дальнейшем будет обрабатываться. Напишем предикаты обработки слов: предикат от слова истенен тогда и только тогда, когда это слово является одной из форм заданного слова.
```prolog
quest_whose(X) :- member(X, [whose, "Whose"]).
quest_what(X) :- member(X, [what, "What"]).
word_is(X) :- member(X, [is, "Is"]).
word_num(X) :- member(X, [number, "Number"]).
word_has(X) :- member(X, [has, "Has"]).
quest_sign(X) :- member(X, ['?']).
have_lst([X], RES) :- member(X, [RES]).
```
Теперь напишем обработку запросов: предикат `ask(X, Res)`.
```prolog
ask(L, Res):-
    L = [WHOSE, NUMBER, IS, NUM,QS], quest_whose(WHOSE), word_num(NUMBER), word_is(IS), quest_sign(QS),
    contacts(Res, NUM), !.
ask(L, Res):-
    L = [WHAT, NUMBER, HAS,CONT,QS], quest_what(WHAT), word_num(NUMBER), word_has(HAS), quest_sign(QS),
    numbers(CONT, Res), !.
ask(L):-
    L = [IS, NUM, NUMBER, CONT, QS], word_is(IS), word_num(NUMBER), quest_sign(QS),
    phone_number(CONT,NUM) -> write("Yes"); write("No"); !.
```
Стоит отметить, что предикат обрабатывает в первых двух случаях целый список номеров и контактов, поэтому необходимо передавать соответствующие списки при вызове предиката. В данном фрагменте программы мною был использован оператор отсечения !. Он останавливает дальнейший поиск решений. Также был использован оператор -> (Не путать с оператором указателем на член класса/структуры из императивных языков C/C++). Конструкция c -> b1; b2; является аналогом следующей конструкции:
```cpp
    if (c){
        b1;
    } else{
        b2;
    }
 ```
 Итак, мы имеем рабочую версию базы данных и обработки некоторых запросов к базе данных. Думаю, бабушка и дедушка могут быть довольны, а также похвастаться перед своими друзьями, какой у них классный внук и какие они продвинутые в сфере IT-технологий.
 Продемонстрируем работу программы:
 ```prolog
 ?-ask([Whose,number,is,[89314456381, 89871754437],?], X).
 X = ['Внук', 'Соседка']
 ?-ask([What,number,has,['Внук','Соседка'],?],Y).
 Y = [89314456381, 89871754437]
 ?-ask([Is,89314456381,number,'Внук',?]).
 Yes
```
# Дальнейшее развитие базы данных
Поговорим немного о дальнейшем развитии созданной нами базы данных. Естественно, написанная нашим упорным и кропотливым трудом база данных является лишь очень простым примером. Она содержит лишь два поля: контакт и телефон, к тому же для такого хранения давным-давно были придуманы телефоны. Поэтому стоит задача об полезном применении логического программирования. Для пожилых людей крайне важно сохранить связь между прошлым и будущим. Между предками и потомками. Поэтому такая задача, как построение семейного дерева, кажется актуальной. Более того, она может быть достаточно эффективно решена средствами языка Prolog. Но для этого потребуется более глубокое изучение языка. Простейшими задачами будут: сохранение дат праздников, памятных дат, также сохранение каких-либо рецептов и вычисление необходимого количества ингридентов для `N` порций того или иного блюда. Задача обработки естественно-языковых запросов также требует немало усилий, однако, является довольно интересной.
# Выводы
Мне кажется, логическое программирование очень просто в изучении, так как не требует знаний фундаментальной информатики (условный, циклов, классов и т.п.), в то же время язык Prolog эффективно решает задачи перебора (мы убедились в этом, когда строили дерево решений), также позволяет реализовать свою базу данных и обработку запросов к ней, что показывает моя программа, которая может быть усовершенствована путем добавления новых полей у объектов, а также путем расширения обрабатываемых естественно-языковых запросов. Мы познакомили наших пожилых людей с базовыми понятиями языка Prolog: факты и правила, база данных, предикат, унификация, запросы, дерево решений, атомы, списки.
Результат проделанной работы можно назвать как "Логическое программирование на Prolog за 5 минут" или же "Prolog для начинающих". Думаю, что несмотря на трудность обучения в преклонном возрасте, для того, чтобы понять изложенный выше материал требуется досаточно маленькое количество знаний (например, что такое предикат). Поэтому даже школьник может научиться писать программы на языке Prolog.
# Список литературы
[Материалы видеолекций по Логическому программированию](https://www.youtube.com/watch?v=spRb_LlCQ_Q)

[Рассчет производной в точке на языке C/C++](https://proginfo.ru/derivative/)

[Синтаксис Prolog](http://rigaux.org/language-study/syntax-across-languages-per-language/Prolog.html)

[Списки в Prolog](https://pro-prof.com/archives/845)
