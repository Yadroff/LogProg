# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Ядров Артем Леонидович

## Результат проверки

Вариант задания:

 - [ ] стандартный, без NLP (на 3)
 - [x] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я получил навыки работы с генеалогическими деревьями в формате GEDCOM, парсинга различных файлов на одном языке скриптов bash. Затем научился обрабатывать графы связей между родственниками на Прологе: определять степень родства между двумя людьми, реализовывать естесственно-языковой интерфейс в системе логического программирования, используя синтаксис DCG.

## Задание

1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате [GEDCOM](https://ru.wikipedia.org/wiki/GEDCOM).
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog  с использованием предиката `child(ребенок, родитель)`, `male(человек)`, `female(человек)`.
3. Реализовать предикат проверки/поиска шурина.
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве.
5. Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.

## Получение родословного дерева

Я зарегестрировался на сервисе MyHeritage.com, создал свое родословное дерево. Потом я экспортировал дерево из этого сервиса в формате GEDCOM.

## Конвертация родословного дерева

Опишите, какой язык/языки вы решили использовать для решения этой задачи и почему. Опишите принцип действия программы и приведите ключевые фрагменты 
программы, позволяющие понять основные моменты решения.

## Предикат поиска родственника
Согласно варианту задания мне нужно реализовать предикат поиска шурина (брата жены). Для его реализации я написал еще два предиката `wife` (поиск жены) и `sibling`(поиск братьев).

Предикат `wife`:
```prolog
wife(Men, Woman):-
    child(X, Men),
    child(X, Woman),
    female(Woman).
 ```
Предикат `sibling`:
```prolog
sibling(Person, Sibling):-
    child(Person, P),
    child(Sibling, P),
    Person \= Sibling.
```
И собственно предикат `shurin`:
```prolog
shurin(Men, Shur):-
    wife(Men, Woman),
    sibling(Woman, Shur),
    male(Shur).
```
## Определение степени родства

Для начала необходимо определить минимальный набор отношений между двумя людьми. Для этого определим отношения мужа, жены, брата, сестры, отца, матери, дочки, сына и шурина. Для определения отношений между двумя любыми людьми будем использовать поиск с итерационным заглублением.
```prolog
check(husband, Wife, Husband) :- wife(Husband, Wife).
check(wife, Husband, Wife) :- wife(Wife, Husband).
check(brother, Y, Brother) :- sibling(Brother, Y), male(Brother).
check(sister, Y, Sister) :- sibling(Sister, Y), female(Sister).
check(father, Child, Father) :- child(Child, Father), male(Father).
check(mother, Child, Mother) :- child(Child, Mother), female(Mother).
check(son, Parent, Child) :- child(Child, Parent), male(Child).
check(daughter, Parent, Child) :- child(Child, Parent), female(Child).
check(shurin, Man, Shurin) :- shurin(Man, Shurin).
```
Затем необходимо определить шаги, которые будет выполнять поиск. Он будет переходить к родителям, детям и брату/сестре.
```prolog
next_iteration(X, Z) :- child(X,Z).
next_iteration(X, Z) :- child(Z,X).
next_iteration(X, Z) :- sibling(X, Z).
```
Так как поиск с итерационным заглублением, то необходимо реализовать натуральный ряд. Ограничение 6 элементов обусловлено тем, что за 6 итераций мы можем найти любую связь (так как количество поколений 3).
```prolog
inc(1).
inc(M):- inc(N), (N < 6 -> M is N+1; !, fail).
```
Поиск реализован следующим образом: если нашлась связь между двумя людьми, то на выходе из рекурсии мы получаем список отношений между льдьми, которые были на пути, если же связь не нашлась, то мы делаем следующий шаг и ищем относительно нового человека.
```prolog
search(Path, X, Y, N) :- N = 1, check(A, X, Y), Path = [A].
search(Path, X, Y, N) :- N > 1, next_iteration(X, Z), N1 is N-1, search(Res, Z, Y, N1), check(B, X, Z), append([B], Res, Path).
```
Теперь непосредственно предикат отношений между двумя людьми. Возможно два случая:
1. Если нам необходимо найти путь (Res является переменной), то выполняем поиск с итерационным углублением.
2. Если нам дан путь, то находим длину пути и ищем элементы с заданной длиной пути.
```prolog
relative(Res, X, Y) :- var(Res), inc(N), N < 6,  search(Res, X, Y, N), Y \= X.
relative(Res, X, Y) :- nonvar(Res), length(Res, N), search(Res, X, Y, N), Y \= X.
```
Результаты работы:
```prolog
?- relative(X, 'Артем Ядров', 'Игорь Ядров').
X = [brother] ;
X = [father, son] ;
...
?- relative(X, 'Артем Ядров', Y).
X = [brother],
Y = 'Игорь Ядров' ;
X = [father],
Y = 'Леонид Ядров' ;
X = [mother],
Y = 'Эльвира Ядрова' ;
X = [father, father],
Y = 'Алексей Ядров' ;
X = [mother, father],
Y = 'Леонид Тарасов' 
X = [mother, brother],
Y = 'Евгений Тарасов' ;
...
relative([brother,mother,father],'Артем Ядров', X).
X = 'Леонид Тарасов' ;

```

## Естественно-языковый интерфейс
Я решил реализовать 3 вида запросов:
1. Is name_1 relation name_2? (Состоят ли name_1 и name_2 в связи relation. Например,  Is 'Артем Ядров' brother 'Игорь Ядров'?).
2. Whose relation is name? (С кем name имеет связь relation. Например, whose father is 'Леонид Ядров').
3. What relations between name_1 and name_2? (В каких связях состоят name_1 и name_2? Например, What relations between 'Леонид Ядров' and 'Эльвира Ядрова'?).
Для этого я использую предикат `question(L)`, принимающий списки определенного вида и выводящий ответ на экран. Для определения слов `What`, `Whose` и т.д. используются соответсвующие предикаты:
```prolog
 question_1(X) :- member(X, [whose, "Whose"]).
question_2(X) :- member(X, [what, "What"]).
rel(X) :- member(X, [relations, relationship]).
bet(X) :- member(X, [between]).
word_1(X) :- member(X, [is, "Is"]).
word_2(X) :- member(X, [and, "And"]).
question_sign(X) :- member(X, ['?']).
```
Предикат ```prolog have_lst([X], REL) :- member(X, [REL]).``` проверяет, является ли ```x``` членом списка ```REL```.
Предикат печати списка:
```prolog
write_list([]).
write_list([X|T]):- write(X), (T \= [] ->  write(" - "), write_list(T); !).
```
Непосредственно предикат ```question(L)```:
```prolog
question(L) :-
    L = [IS, NAME_0, REL,NAME_1, QS],
    word_1(IS), relative(X, NAME_1,NAME_0), !,
    have_lst(X, REL), question_sign(QS),
    write(NAME_0), write(" is "), write(REL), write(" "), write(NAME_1),write(".").
question(L) :-
    L = [WHOSE, REL, IS, NAME, QS],
    question_1(WHOSE), word_1(IS), question_sign(QS),
    relative([REL], NAME, Ans),
    write(NAME), write(" is "), write(REL), write(" "), write(Ans), write("."), nl.
question(L) :-
    L = [WHAT, RELATIONS, BETWEEN, NAME_1, AND, NAME_0,QS],
    question_2(WHAT), rel(RELATIONS), bet(BETWEEN), word_2(AND), question_sign(QS),
    relative(Res, NAME_1, NAME_0),
    write_list(Res), nl.
 ```
 Примеры использования:
 ```prolog
 ?- question([Is,'Леонид Ядров',father,'Артем Ядров',?]).
Леонид Ядров is father Артем Ядров.
?- question([Whose,brother,is,'Игорь Ядров',?]).
Игорь Ядров is brother Артем Ядров.
?- question([What,relations,between,'Артем Ядров',and,'Евгений Тарасов',?]).
mother - brother
mother - father - son
mother - mother - son
father - son - mother - brother
mother - brother - sister - brother
mother - son - mother - brother
father - shurin
...
 ```

## Выводы

Prolog яляется логическим языков программирования, что дает свои плюсы и минусы, создание предикатов является логически понятным и интуитивно простым для человнка, т.к. по сути мы так размышляем, в прологе есть правила и факты, факт это что-то известное, то что мы знаем, правило - закономерность, базирующаяся на фактах, запрос пролога представляет обход дерева и бэктрекинг. В прологе есть механизм отсечения, который позволяет ускорять работу программы, убирать лишние вхождения, на прологе можно писать многие стандартные алгоритмы, такие как dfs, bfs, с его помощью удобно решать логические задачки, также Prolog удобно использовать для описания некоторых математических предикатов. Я научился в Prolog-е работать со списками, писать различные предикаты отношений, объединять предикаты в один общий предикат, использовать рекурсию, механизм отсечения. Prolog позволяет создавать программы с набором очень гибких предикатов, тем самым на нем достаточно просто писать простые программы, использующие в виде запроса естественный язык.
